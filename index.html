<script>
// ... keep everything else unchanged above ...

async function runReportAndDownload({ startUrl, filenameBase, format='json' }){
  lastStartUrl = startUrl;
  $("#btnRegenLast").disabled = false;
  $("#lastStartUrl").textContent = `Last: ${ (new URL(buildUrl(startUrl))).toString().replace(/(api_key=)[^&]+/ig,'$1****') }`;

  // Kickoff expects JSON (202 Accepted envelope)
  let start;
  try {
    start = await apiFetchSmart(startUrl, { headers: { 'Accept':'application/json' } });
  } catch (e) {
    start = await apiFetchSmart(startUrl, { headers: { 'Accept':'application/json' } }, { tryQueryKeyFallback: true });
  }
  log('GET', start.url.replace(/(api_key=)[^&]+/ig,'$1****'));

  if (start.status === 200) {
    return downloadFromResponse(start, filenameBase, format);
  }

  if (start.status !== 202) {
    throw new Error(`Unexpected response: HTTP ${start.status}`);
  }

  const body = await start.res.json();
  const taskId = body.task_id || body.id;
  lastTaskId = taskId || lastTaskId;
  if (lastTaskId){
    $("#taskIdInput").value = lastTaskId;
    $("#lastTaskIdText").textContent = `Last task: ${lastTaskId}`;
  }
  const statusPath = body.check_status_url || body.status_url || `/reports/status/${encodeURIComponent(taskId)}`;
  const statusUrl  = buildUrl(statusPath);
  log(`Task queued: ${taskId}. Polling status via ${statusUrl}‚Ä¶`);

  // üîÅ Poll until completed; CAPTURE the COMPLETED JSON here
  let completedJson = null;
  while (true) {
    await new Promise(r => setTimeout(r, 3000));
    const status = await apiFetchSmart(statusUrl, { headers:{ 'Accept':'application/json' } });
    const js = await status.res.json();
    const st = (js.status || js.result?.status || '').toLowerCase();
    log(`status=${st || 'unknown'}`);
    if (st === 'completed' || st === 'success' || st === 'done') { completedJson = js; break; }
    if (st === 'failed' || st === 'error') throw new Error('Report generation failed.');
  }

  // ‚¨áÔ∏è No second GET ‚Äî use the completed payload we just received
  let statusJson = completedJson;

  // Pick artifact; ALWAYS prefer s3_url per your latest backend
  const art = pickArtifactFromStatus(statusJson, format);
  if (art){
    const link = art.s3_url || art.url || null;
    if (link){
      await downloadArtifactLink(link, art.filename || `${filenameBase}.${extFrom(format)}`, format);
      return;
    }
    if (art.data){
      await downloadArtifactData(art, `${filenameBase}.${extFrom(format)}`, format);
      return;
    }
  }

  // Fallback (very rare): completed=true on the starter URL
  const dlUrl = withParam(startUrl, 'completed', 'true');
  const dl = await apiFetchSmart(dlUrl, { headers:{ 'Accept': acceptFor(format) } });
  log('GET', dl.url.replace(/(api_key=)[^&]+/ig,'$1****'));
  return downloadFromResponse(dl, filenameBase, format);
}

// ... keep everything else unchanged below ...
</script>
